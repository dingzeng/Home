.NET中的类型
===========

## 所有的类型都继承自System.Object

声明一个类型时，如果没有为其指定基类，.NET会让它默认继承自System.Object类，如下所示：
```
public class User{
    //隐式继承
}
```
```
public class User : System.Object{
    //显示继承
}
```

这样一来.NET中所有变量都继承了System.Object类中的方法： 
- Equals：判断了两个对象是否具有相等的值
- GetHashCode：返回对象值得哈希码，Dictionary中的Key是以Key对象的哈希码作为实际的Key，这个方法不应该设计到System.Object类中，应该作为接口声明
- ToString：返回对象的字符串表示，默认返回类型全名称，一般会重写改方法
- GetType：返回对象的一个Type对象，一般跟反射结合使用

`new`操作所做的事情：
1. 计算类型所需字节空间，包括类型及其所有基类的字段和开销成员(类型对象指针、同步块索引)
2. 分配成员所需的字节空间，并初始化为0
3. 初始化类型对象指针、同步块索引
4. 调用实例构造函数，初始化成员，编译器会将类型的构造函数中自动生成调用父类构造函数的代码，所以会先调用父类的构造函数
5. 返回指向创建对象的引用
 
## 类型安全与转换

类型安全：CLR能够明确的知道每个对象的实际类型，不允许对象伪装成其它的类型，这是通过System.Object的密封方法GetType实现的。
类型转换：类型转换分为显示转换和隐式转换，子类对象转换为父类对象时称为隐式转换，相反则为显示转换，需要使用强制类型转换。
类型转换操作符：`is`用来判断对象是否是类型的兼容类型，返回一个布尔值，`as`用来将对象转换为指定的类型，如果不兼容则为`null `

## 命名空间

- 命名空间是类型的逻辑组织方式
- CLR不关心命名空间，编译器编译时已经将类型名替换成了全名称
- 使用`namespace`关键字使用命名空间，使用`using`关键字引入命名空间


